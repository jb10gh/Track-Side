/**
 * Auto Email Export Service
 * Provides automatic email generation and sending for match reports
 */

export class AutoEmailExportService {
  constructor() {
    this.defaultCoachEmail = 'coach@example.com';
  }

  /**
   * Create automatic email configuration for match data
   * @param {Object} matchData - Match data including events, scores, etc.
   * @returns {Promise<Object>} Email configuration object
   */
  async createAutoEmail(matchData) {
    const subject = this.generateSubject(matchData);
    const body = this.generateBody(matchData);
    const csvAttachment = await this.generateCSV(matchData);
    const recipient = this.getDefaultCoachEmail();

    return {
      subject,
      body,
      csvAttachment,
      recipient,
      preFilled: true,
      timestamp: Date.now()
    };
  }

  /**
   * Generate email subject line
   * @param {Object} matchData - Match data
   * @returns {string} Formatted subject line
   */
  generateSubject(matchData) {
    const date = new Date(matchData.timestamp).toLocaleDateString();
    const score = `${matchData.myScore}-${matchData.opponentScore}`;
    const opponentName = matchData.opponentName || 'Opponent';
    
    return `Match Report: ${opponentName} (${score}) - ${date}`;
  }

  /**
   * Generate email body content
   * @param {Object} matchData - Match data
   * @returns {string} Formatted email body
   */
  generateBody(matchData) {
    const events = this.formatEvents(matchData.events);
    const statistics = this.generateStatistics(matchData);
    
    return `
Match Summary
=============
Opponent: ${matchData.opponentName || 'Opponent'}
Date: ${new Date(matchData.timestamp).toLocaleDateString()}
Final Score: ${matchData.myScore} - ${matchData.opponentScore}
Duration: ${matchData.finalTime || 'N/A'}

Events:
${events}

Statistics:
${statistics}

Data file attached for detailed analysis.

---
Generated by Sideline Stats - Professional Sports Analytics
    `.trim();
  }

  /**
   * Format events for email display
   * @param {Array} events - Array of game events
   * @returns {string} Formatted events string
   */
  formatEvents(events) {
    if (!events || events.length === 0) {
      return 'No events recorded';
    }

    return events
      .slice()
      .reverse()
      .map(event => {
        const typeStr = event.meta?.isPK ? 'Goal (PK)' : 
                       event.type.charAt(0).toUpperCase() + event.type.slice(1);
        const teamStr = event.team === 'us' ? 'Us' : 'Them';
        const label = event.label || 'Unnamed';
        return `[${event.gameTime}] ${typeStr} (${teamStr}) - ${label}`;
      })
      .join('\n');
  }

  /**
   * Generate match statistics
   * @param {Object} matchData - Match data
   * @returns {string} Formatted statistics
   */
  generateStatistics(matchData) {
    if (!matchData.events || matchData.events.length === 0) {
      return '- No events recorded';
    }

    const ourGoals = matchData.events.filter(e => e.type === 'goal' && e.team === 'us').length;
    const theirGoals = matchData.events.filter(e => e.type === 'goal' && e.team === 'them').length;
    const totalEvents = matchData.events.length;
    const penalties = matchData.events.filter(e => e.type === 'penalty').length;
    const cards = matchData.events.filter(e => e.type === 'card').length;

    return `- Our Goals: ${ourGoals}
- Their Goals: ${theirGoals}
- Total Events: ${totalEvents}
- Penalties: ${penalties}
- Cards: ${cards}
- Goal Difference: ${ourGoals - theirGoals}`;
  }

  /**
   * Generate CSV file attachment
   * @param {Object} matchData - Match data
   * @returns {Promise<File>} CSV file object
   */
  async generateCSV(matchData) {
    const headers = ['Time', 'Type', 'Team', 'Label', 'PK', 'Timestamp'];
    const rows = matchData.events.map(event => [
      event.gameTime || '',
      event.type || '',
      event.team === 'us' ? 'Us' : 'Them',
      event.label || '',
      event.meta?.isPK ? 'Yes' : 'No',
      event.timestamp || ''
    ]);

    const csvContent = [
      headers.join(','),
      ...rows.map(row => 
        row.map(cell => `"${cell}"`).join(',')
      )
    ].join('\n');

    const filename = `match-report-${matchData.opponentName || 'opponent'}-${Date.now()}.csv`;
    
    return new File([csvContent], filename, {
      type: 'text/csv'
    });
  }

  /**
   * Get default coach email
   * @returns {string} Default coach email address
   */
  getDefaultCoachEmail() {
    // Try to get from localStorage or use default
    const savedEmail = localStorage.getItem('defaultCoachEmail');
    return savedEmail || this.defaultCoachEmail;
  }

  /**
   * Trigger email client with pre-filled content
   * @param {Object} config - Email configuration
   * @returns {Promise<void>}
   */
  async triggerEmailClient(config) {
    const { subject, body, recipient } = config;
    
    // Build mailto URL
    const params = new URLSearchParams({
      to: recipient,
      subject: subject,
      body: body
    });

    const mailtoUrl = `mailto:${recipient}?${params.toString()}`;
    
    // Open email client
    window.location.href = mailtoUrl;
  }

  /**
   * Create enhanced email with multiple recipients
   * @param {Object} matchData - Match data
   * @param {Array} recipients - Array of email addresses
   * @param {Object} options - Email options
   * @returns {Promise<Object>} Enhanced email configuration
   */
  async createEnhancedEmail(matchData, recipients = [], options = {}) {
    const {
      template = 'professional',
      includeCSV = true,
      includeImages = false,
      customMessage = ''
    } = options;

    const baseConfig = await this.createAutoEmail(matchData);
    
    // Enhance based on template
    let enhancedBody = baseConfig.body;
    
    switch (template) {
      case 'professional':
        enhancedBody = this.applyProfessionalTemplate(matchData, customMessage);
        break;
      case 'casual':
        enhancedBody = this.applyCasualTemplate(matchData, customMessage);
        break;
      case 'detailed':
        enhancedBody = this.applyDetailedTemplate(matchData, customMessage);
        break;
    }

    return {
      ...baseConfig,
      recipients: recipients.length > 0 ? recipients : [baseConfig.recipient],
      body: enhancedBody,
      template,
      includeCSV,
      includeImages,
      customMessage
    };
  }

  /**
   * Apply professional email template
   * @param {Object} matchData - Match data
   * @param {string} customMessage - Custom message
   * @returns {string} Professional email body
   */
  applyProfessionalTemplate(matchData, customMessage = '') {
    const baseBody = this.generateBody(matchData);
    
    if (customMessage) {
      return `${customMessage}

${baseBody}`;
    }
    
    return baseBody;
  }

  /**
   * Apply casual email template
   * @param {Object} matchData - Match data
   * @param {string} customMessage - Custom message
   * @returns {string} Casual email body
   */
  applyCasualTemplate(matchData, customMessage = '') {
    const date = new Date(matchData.timestamp).toLocaleDateString();
    const score = `${matchData.myScore}-${matchData.opponentScore}`;
    const opponentName = matchData.opponentName || 'Opponent';
    
    let body = `Great game vs ${opponentName}! 

Final score: ${score}
Date: ${date}

`;

    if (matchData.events && matchData.events.length > 0) {
      body += `Key moments:
${this.formatEvents(matchData.events)}

`;
    }

    if (customMessage) {
      body += `${customMessage}

`;
    }

    body += `Full stats and data attached!

Go team! ðŸ†`;

    return body.trim();
  }

  /**
   * Apply detailed email template
   * @param {Object} matchData - Match data
   * @param {string} customMessage - Custom message
   * @returns {string} Detailed email body
   */
  applyDetailedTemplate(matchData, customMessage = '') {
    const baseBody = this.generateBody(matchData);
    
    // Add detailed analysis
    const detailedAnalysis = this.generateDetailedAnalysis(matchData);
    
    let fullBody = baseBody;

    if (detailedAnalysis) {
      fullBody += `

Detailed Analysis:
${detailedAnalysis}`;
    }

    if (customMessage) {
      fullBody += `

Coach Notes:
${customMessage}`;
    }

    return fullBody.trim();
  }

  /**
   * Generate detailed match analysis
   * @param {Object} matchData - Match data
   * @returns {string} Detailed analysis
   */
  generateDetailedAnalysis(matchData) {
    if (!matchData.events || matchData.events.length === 0) {
      return 'No events to analyze';
    }

    const ourGoals = matchData.events.filter(e => e.type === 'goal' && e.team === 'us');
    const theirGoals = matchData.events.filter(e => e.type === 'goal' && e.team === 'them');
    const penalties = matchData.events.filter(e => e.type === 'penalty');
    const cards = matchData.events.filter(e => e.type === 'card');

    let analysis = [];

    // Goal timing analysis
    if (ourGoals.length > 0) {
      const firstOurGoal = ourGoals[0];
      analysis.push(`First goal scored at ${firstOurGoal.gameTime}`);
      
      if (ourGoals.length > 1) {
        const lastOurGoal = ourGoals[ourGoals.length - 1];
        analysis.push(`Final goal scored at ${lastOurGoal.gameTime}`);
      }
    }

    // Penalty analysis
    if (penalties.length > 0) {
      analysis.push(`${penalties.length} penalties recorded`);
      const pkGoals = penalties.filter(p => p.meta?.isPK);
      if (pkGoals.length > 0) {
        analysis.push(`${pkGoals.length} penalty goals converted`);
      }
    }

    // Card analysis
    if (cards.length > 0) {
      const yellowCards = cards.filter(c => c.meta?.cardType === 'yellow');
      const redCards = cards.filter(c => c.meta?.cardType === 'red');
      
      if (yellowCards.length > 0) {
        analysis.push(`${yellowCards.length} yellow cards`);
      }
      if (redCards.length > 0) {
        analysis.push(`${redCards.length} red cards`);
      }
    }

    // Performance summary
    const possession = this.calculatePossession(matchData);
    if (possession) {
      analysis.push(`Estimated possession: ${possession}`);
    }

    return analysis.length > 0 ? analysis.join('\n- ') : 'No significant patterns identified';
  }

  /**
   * Calculate estimated possession based on events
   * @param {Object} matchData - Match data
   * @returns {string} Possession estimate
   */
  calculatePossession(matchData) {
    if (!matchData.events || matchData.events.length === 0) {
      return null;
    }

    const ourEvents = matchData.events.filter(e => e.team === 'us');
    const theirEvents = matchData.events.filter(e => e.team === 'them');
    
    const ourPossession = (ourEvents.length / matchData.events.length) * 100;
    const theirPossession = (theirEvents.length / matchData.events.length) * 100;
    
    return `${Math.round(ourPossession)}% - ${Math.round(theirPossession)}%`;
  }

  /**
   * Validate email configuration
   * @param {Object} config - Email configuration
   * @returns {Object} Validation result
   */
  validateEmailConfig(config) {
    const errors = [];
    const warnings = [];

    // Check required fields
    if (!config.subject) {
      errors.push('Subject is required');
    }

    if (!config.body) {
      errors.push('Body is required');
    }

    if (!config.recipients || config.recipients.length === 0) {
      errors.push('At least one recipient is required');
    }

    // Validate email addresses
    if (config.recipients) {
      config.recipients.forEach(email => {
        if (!this.isValidEmail(email)) {
          errors.push(`Invalid email address: ${email}`);
        }
      });
    }

    // Check for potential issues
    if (config.body && config.body.length > 10000) {
      warnings.push('Email body is very long, may be truncated by some email clients');
    }

    if (config.csvAttachment && config.csvAttachment.size > 5 * 1024 * 1024) { // 5MB
      warnings.push('CSV attachment is large, may be rejected by some email providers');
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }

  /**
   * Validate email address format
   * @param {string} email - Email address
   * @returns {boolean} True if valid
   */
  isValidEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  /**
   * Save default coach email
   * @param {string} email - Coach email address
   */
  saveDefaultCoachEmail(email) {
    if (this.isValidEmail(email)) {
      localStorage.setItem('defaultCoachEmail', email);
      this.defaultCoachEmail = email;
      return true;
    }
    return false;
  }

  /**
   * Get email history
   * @returns {Array} Array of sent email configurations
   */
  getEmailHistory() {
    const history = localStorage.getItem('emailHistory');
    return history ? JSON.parse(history) : [];
  }

  /**
   * Save email to history
   * @param {Object} config - Email configuration
   */
  saveToHistory(config) {
    const history = this.getEmailHistory();
    const entry = {
      ...config,
      sentAt: Date.now(),
      id: Date.now().toString()
    };

    // Keep only last 50 entries
    const updatedHistory = [entry, ...history].slice(0, 50);
    localStorage.setItem('emailHistory', JSON.stringify(updatedHistory));
  }
}

// Export singleton instance
export const autoEmailExportService = new AutoEmailExportService();
