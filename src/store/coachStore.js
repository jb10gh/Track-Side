import { create } from 'zustand';
import { persist } from 'zustand/middleware';

/**
 * Coach Contact Store - JavaScript Mastery Implementation
 * 
 * Features:
 * - Persistent storage for coach contacts
 * - Default coach management
 * - Contact validation and formatting
 * - Email composition helpers
 */

// Email validation regex
const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

// Coach contact validation
const validateCoachContact = (coach) => {
    const errors = [];
    
    if (!coach.name || coach.name.trim().length < 2) {
        errors.push('Coach name must be at least 2 characters');
    }
    
    if (!coach.email || !EMAIL_REGEX.test(coach.email)) {
        errors.push('Valid email address is required');
    }
    
    if (!coach.role || coach.role.trim().length < 2) {
        errors.push('Coach role must be at least 2 characters');
    }
    
    return {
        isValid: errors.length === 0,
        errors
    };
};

// Format email for mailto protocol
const formatEmailForMailto = (emailData) => {
    const { to, subject, body } = emailData;
    
    // Encode subject and body for URL
    const encodedSubject = encodeURIComponent(subject);
    const encodedBody = encodeURIComponent(body);
    
    return `mailto:${to}?subject=${encodedSubject}&body=${encodedBody}`;
};

// Generate professional email subject
const generateEmailSubject = (matchData) => {
    const date = new Date(matchData.timestamp).toLocaleDateString();
    const result = matchData.myScore > matchData.opponentScore ? 'WIN' : 
                   matchData.myScore < matchData.opponentScore ? 'LOSS' : 'DRAW';
    
    return `ðŸ“Š Match Report: ${matchData.opponentName} (${result}) - ${date}`;
};

// Generate comprehensive email body
const generateEmailBody = (matchData, coachInfo, formatTime) => {
    const stats = calculateMatchStats(matchData);
    
    return `Dear ${coachInfo.name},

${generateMatchSummary(matchData, formatTime)}
${generateDetailedStats(stats)}
${generateActionItems(stats)}

The complete CSV data is attached for your detailed analysis.

Best regards,
Sideline Stats Tracker
${new Date().toLocaleDateString()}

---
Generated by Sideline Stats App
Match ID: ${matchData.id || 'Unknown'}`;
};

// Calculate match statistics
const calculateMatchStats = (matchData) => {
    const ourGoals = matchData.events.filter(e => e.type === 'goal' && e.team === 'us').length;
    const theirGoals = matchData.events.filter(e => e.type === 'goal' && e.team === 'them').length;
    const ourPenalties = matchData.events.filter(e => e.type === 'penalty' && e.team === 'us').length;
    const theirPenalties = matchData.events.filter(e => e.type === 'penalty' && e.team === 'them').length;
    
    return {
        ourGoals,
        theirGoals,
        ourPenalties,
        theirPenalties,
        totalEvents: matchData.events.length,
        duration: matchData.finalTime,
        goalDifference: ourGoals - theirGoals
    };
};

// Generate match summary section
const generateMatchSummary = (matchData, formatTime) => {
    return `ðŸ“Š MATCH SUMMARY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ðŸ† Match: Us vs ${matchData.opponentName}
âš¡ Final Score: ${matchData.myScore}-${matchData.opponentScore}
ðŸ“… Date: ${new Date(matchData.timestamp).toLocaleDateString()}
â±ï¸ Duration: ${formatTime ? formatTime(matchData.finalTime) : matchData.finalTime || 'Unknown'}
ðŸ“ Events: ${matchData.events.length} total`;
};

// Generate detailed statistics
const generateDetailedStats = (stats) => {
    return `ðŸ“ˆ DETAILED STATISTICS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âš½ Goals Scored: ${stats.ourGoals}
ðŸ¥… Goals Conceded: ${stats.theirGoals}
ðŸŸ¨ Penalties: ${stats.ourPenalties}
ðŸŸ¥ Opponent Penalties: ${stats.theirPenalties}
ðŸ“Š Goal Difference: ${stats.goalDifference > 0 ? '+' : ''}${stats.goalDifference}`;
};

// Generate action items for coach
const generateActionItems = (stats) => {
    const actionItems = [];
    
    if (stats.goalDifference > 0) {
        actionItems.push('âœ… Strong offensive performance - maintain momentum');
    } else if (stats.goalDifference < 0) {
        actionItems.push('ðŸŽ¯ Focus on defensive organization in next training');
    }
    
    if (stats.ourPenalties > stats.theirPenalties) {
        actionItems.push('âš ï¸ Review discipline - reduce penalty count');
    }
    
    if (stats.ourGoals === 0) {
        actionItems.push('ðŸ”¥ Work on finishing and scoring opportunities');
    }
    
    if (actionItems.length === 0) {
        actionItems.push('ðŸ‘ Solid performance - continue current strategy');
    }
    
    return `ðŸŽ¯ COACHING NOTES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
${actionItems.join('\n')}`;
};

export const useCoachStore = create(
    persist(
        (set, get) => ({
            // State
            coaches: [],
            defaultCoachId: null,
            lastSubmission: null,
            submissionHistory: [],
            
            // Actions
            addCoach: (coachData) => {
                const validation = validateCoachContact(coachData);
                if (!validation.isValid) {
                    throw new Error(`Invalid coach data: ${validation.errors.join(', ')}`);
                }
                
                const newCoach = {
                    id: crypto.randomUUID(),
                    ...coachData,
                    createdAt: Date.now(),
                    isActive: true
                };
                
                set((state) => ({
                    coaches: [...state.coaches, newCoach],
                    defaultCoachId: state.defaultCoachId || newCoach.id
                }));
                
                return newCoach;
            },
            
            updateCoach: (coachId, updates) => {
                const currentCoach = get().coaches.find(c => c.id === coachId);
                if (!currentCoach) {
                    throw new Error('Coach not found');
                }
                
                const updatedCoach = { ...currentCoach, ...updates, updatedAt: Date.now() };
                const validation = validateCoachContact(updatedCoach);
                
                if (!validation.isValid) {
                    throw new Error(`Invalid coach data: ${validation.errors.join(', ')}`);
                }
                
                set((state) => ({
                    coaches: state.coaches.map(c => c.id === coachId ? updatedCoach : c)
                }));
                
                return updatedCoach;
            },
            
            deleteCoach: (coachId) => {
                set((state) => {
                    const newCoaches = state.coaches.filter(c => c.id !== coachId);
                    const newDefaultId = state.defaultCoachId === coachId 
                        ? (newCoaches.length > 0 ? newCoaches[0].id : null)
                        : state.defaultCoachId;
                    
                    return {
                        coaches: newCoaches,
                        defaultCoachId: newDefaultId
                    };
                });
            },
            
            setDefaultCoach: (coachId) => {
                const coach = get().coaches.find(c => c.id === coachId);
                if (!coach) {
                    throw new Error('Coach not found');
                }
                
                set({ defaultCoachId: coachId });
            },
            
            getDefaultCoach: () => {
                const state = get();
                return state.coaches.find(c => c.id === state.defaultCoachId) || state.coaches[0] || null;
            },
            
            generateEmailContent: (matchData, coachId = null, formatTime) => {
                const coach = coachId 
                    ? get().coaches.find(c => c.id === coachId)
                    : get().getDefaultCoach();
                
                if (!coach) {
                    throw new Error('No coach available for email generation');
                }
                
                return {
                    to: coach.email,
                    subject: generateEmailSubject(matchData),
                    body: generateEmailBody(matchData, coach, formatTime),
                    coachName: coach.name,
                    mailtoUrl: null // Will be set by formatEmailForMailto
                };
            },
            
            openEmailClient: (emailData) => {
                const mailtoUrl = formatEmailForMailto(emailData);
                
                // Track submission
                set((state) => ({
                    lastSubmission: {
                        timestamp: Date.now(),
                        matchId: emailData.matchId,
                        coachId: emailData.coachId,
                        emailData: emailData
                    },
                    submissionHistory: [
                        ...state.submissionHistory,
                        {
                            id: crypto.randomUUID(),
                            timestamp: Date.now(),
                            matchId: emailData.matchId,
                            coachId: emailData.coachId,
                            type: 'email'
                        }
                    ].slice(-20) // Keep last 20 submissions
                }));
                
                // Open email client
                window.location.href = mailtoUrl;
                
                return {
                    success: true,
                    mailtoUrl,
                    message: 'Email client opened successfully'
                };
            },
            
            // Utility methods
            validateCoachEmail: (email) => {
                return EMAIL_REGEX.test(email);
            },
            
            getCoachCount: () => {
                return get().coaches.length;
            },
            
            getActiveCoaches: () => {
                return get().coaches.filter(c => c.isActive);
            }
        }),
        {
            name: 'sideline-stats-coach-storage',
            version: 1
        }
    )
);

// Export utility functions for testing
export const CoachUtils = {
    validateCoachContact,
    formatEmailForMailto,
    generateEmailSubject,
    generateEmailBody,
    calculateMatchStats
};
